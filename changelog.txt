Spec 1.0 - Initial release

----

Spec 1.1 - Updated, minor fixes.

diff --git a/A2/src/main/java/uq/comp3506/a2/Problems.java b/A2/src/main/java/uq/comp3506/a2/Problems.java
index aa46863..91673b7 100644
--- a/A2/src/main/java/uq/comp3506/a2/Problems.java
+++ b/A2/src/main/java/uq/comp3506/a2/Problems.java
@@ -32,6 +32,8 @@ public class Problems {
      * @param lightIntervals The list of light intervals in [0, tunnelLength];
      * that is, all light interval values are >= 0 and <= tunnelLength
      * @return The minimum radius value required to illuminate the tunnel
+     * or -1 if no light fittings are provided
+     * Note: We promise that the input List will be an ArrayList.
      */
     public static double tunnelLighting(int tunnelLength, List<Integer> lightIntervals) {
         return -1;
@@ -43,6 +45,8 @@ public class Problems {
      *              Edge, which stores two vertices and a value. Vertex identifiers
      *              are NOT GUARANTEED to be contiguous or in a given range.
      * @return The corresponding TopologyType.
+     * Note: We promise not to provide any self loops, double edges, or isolated
+     * vertices.
      */
     public static <S, U> TopologyType topologyDetection(List<Edge<S, U>> edgeList) {
         TopologyType dummy = TopologyType.UNKNOWN;
@@ -60,6 +64,8 @@ public class Problems {
      *         of a reachable station (within the time threshold), and the second
      *         element is the minimum cost of reaching that given station. The
      *         order of the list is not important.
+     * Note: We promise that S will be of Integer type.
+     * Note: You should return the origin in your result with a cost of zero.
      */
     public static <S, U> List<Entry<Integer, Integer>> routeManagement(List<Edge<S, U>> edgeList,
                                                           Vertex<S> origin, int threshold) {
diff --git a/A2/src/main/java/uq/comp3506/a2/structures/Heap.java b/A2/src/main/java/uq/comp3506/a2/structures/Heap.java
index 30648fd..e2c845a 100644
--- a/A2/src/main/java/uq/comp3506/a2/structures/Heap.java
+++ b/A2/src/main/java/uq/comp3506/a2/structures/Heap.java
@@ -114,8 +114,10 @@ public class Heap<K extends Comparable<K>, V> {

     /**
      * We assume smaller keys have higher priority, so this method will
-     * remove the highest priority element from the heap.
+     * remove and return the highest priority element from the heap.
      * Time complexity for full marks: O(log n)
+     * @return the Entry at the top of the heap
+     * Note: Return null if empty.
      */
     public Entry<K, V> removeMin() {
         return null;
@@ -126,6 +128,8 @@ public class Heap<K extends Comparable<K>, V> {
      * return a copy of the highest priority element in the heap, but it
      * wont remove it.
      * Time complexity for full marks: O(1)
+     * @return the Entry at the top of the heap
+     * Note: Return null if empty
      */
     public Entry<K, V> peekMin() {
         return null;
diff --git a/A2/src/main/java/uq/comp3506/a2/structures/OrderedMap.java b/A2/src/main/java/uq/comp3506/a2/structures/OrderedMap.java
index cb5bfdb..4eb08d7 100644
--- a/A2/src/main/java/uq/comp3506/a2/structures/OrderedMap.java
+++ b/A2/src/main/java/uq/comp3506/a2/structures/OrderedMap.java
@@ -176,7 +176,7 @@ public class OrderedMap<K extends Comparable<K>, V> implements MapInterface<K, V
     }


-    /** Returns a list of keys in the range [lo, hi]*/
+    /** Returns a SORTED list of keys in the range [lo, hi]*/
     public List<K> keysInRange(K lo, K hi) {
         ArrayList<K> result = new ArrayList<>();
         // Implement me!
diff --git a/A2/test/TestProblems.java b/A2/test/TestProblems.java
index 5d08c6a..31de687 100644
--- a/A2/test/TestProblems.java
+++ b/A2/test/TestProblems.java
@@ -105,7 +105,8 @@ public class TestProblems {
                 new Entry<>(2, 4),
                 new Entry<>(3, 4),
                 new Entry<>(4, 4),
-                new Entry<>(5, 2)
+                new Entry<>(5, 0),
+                new Entry<>(6, 2)
         ));

         List<Entry<Integer, Integer>> actual = Problems.routeManagement(edgeList, origin, threshold);
@@ -127,9 +128,9 @@ public class TestProblems {
         tunnels.add(new Tunnel(4,1,3,1.6));
         tunnels.add(new Tunnel(5, 4,4,1.2));

-         assert Problems.totallyFlooded(tunnels) == 3;
+         assert Problems.totallyFlooded(tunnels) == 2;
         // you can use this one if you prefer jUnit testing instead
-        // assertEquals(3, Problems.totallyFlooded(tunnels));
+        // assertEquals(2, Problems.totallyFlooded(tunnels));
     }

